<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>5.5. Import Hex Dump</title><link rel="stylesheet" type="text/css" href="ws.css"><meta name="generator" content="DocBook XSL Stylesheets V1.79.1"><link rel="home" href="index.html" title="Wireshark User’s Guide"><link rel="up" href="ChapterIO.html" title="Chapter 5. File Input, Output, And Printing"><link rel="prev" href="ChIOMergeSection.html" title="5.4. Merging Capture Files"><link rel="next" href="ChIOFileSetSection.html" title="5.6. File Sets"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">5.5. Import Hex Dump</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ChIOMergeSection.html">Prev</a> </td><th width="60%" align="center">Chapter 5. File Input, Output, And Printing</th><td width="20%" align="right"> <a accesskey="n" href="ChIOFileSetSection.html">Next</a></td></tr></table><hr></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ChIOImportSection"></a>5.5. Import Hex Dump</h2></div></div></div>

<p>Wireshark can read in a hex dump and write the data described into a
temporary libpcap capture file. It can read hex dumps with multiple packets in
them, and build a capture file of multiple packets. It is also capable of
generating dummy Ethernet, IP and UDP, TCP, or SCTP headers, in order to build
fully processable packet dumps from hexdumps of application-level data only.
Alternatively a Dummy PDU header can be added to specify a dissector the data
should be passed to initially.</p>
<p>Two methods for converting the input are supported:</p>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_standard_ascii_hexdumps"></a>5.5.1. Standard ASCII Hexdumps</h3></div></div></div>

<p>Wireshark understands a hexdump of the form generated by <code class="literal">od -Ax -tx1 -v</code>. In
other words, each byte is individually displayed and surrounded with a space.
Each line begins with an offset describing the position in the packet, each
new packet starts with an offset of 0 and there is a space separating the
offset from the following bytes. The offset is a hex number (can also be octal
or decimal), of more than two hex digits.
Here is a sample dump that can be imported:</p>
<pre class="screen">000000 00 e0 1e a7 05 6f 00 10 ........
000008 5a a0 b9 12 08 00 46 00 ........
000010 03 68 00 00 00 00 0a 2e ........
000018 ee 33 0f 19 08 7f 0f 19 ........
000020 03 80 94 04 00 00 10 01 ........
000028 16 a2 0a 00 03 50 00 0c ........
000030 01 01 0f 19 03 80 11 01 ........</pre>
<p>There is no limit on the width or number of bytes per line. Also the text dump
at the end of the line is ignored. Byte and hex numbers can be uppercase or
lowercase. Any text before the offset is ignored, including email forwarding
characters <span class="emphasis"><em>&gt;</em></span>. Any lines of text between the bytestring lines are ignored.
The offsets are used to track the bytes, so offsets must be correct. Any line
which has only bytes without a leading offset is ignored. An offset is
recognized as being a hex number longer than two characters. Any text after the
bytes is ignored (e.g. the character dump). Any hex numbers in this text are
also ignored. An offset of zero is indicative of starting a new packet, so a
single text file with a series of hexdumps can be converted into a packet
capture with multiple packets. Packets may be preceded by a timestamp. These are
interpreted according to the format given. If not the first packet is
timestamped with the current time the import takes place. Multiple packets are
written with timestamps differing by one nanosecond each. In general, short of
these restrictions, Wireshark is pretty liberal about reading in hexdumps and
has been tested with a variety of mangled outputs (including being forwarded
through email multiple times, with limited line wrap etc.)</p>
<p>There are a couple of other special features to note. Any line where the first
non-whitespace character is <code class="literal">#</code> will be ignored as a comment. Any line beginning
with <code class="literal">#TEXT2PCAP</code> is a directive and options can be inserted after this command to
be processed by Wireshark. Currently there are no directives implemented. In the
future these may be used to give more fine grained control on the dump and the
way it should be processed e.g. timestamps, encapsulation type etc.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_regular_text_dumps"></a>5.5.2. Regular Text Dumps</h3></div></div></div>

<p>Wireshark is also capable of scanning the input using a custom perl regular
expression as specified by GLib’s <a class="ulink" href="https://developer.gnome.org/glib/stable/glib-regex-syntax.html" target="_top">GRegex here</a>.
Using a regex capturing a single packet in the given file
wireshark will search the given file from start to the second to last character
(the last character has to be <code class="literal">\n</code> and is ignored)
for non-overlapping (and non-empty) strings matching the given regex and then
identify the fields to import using named capturing subgroups. Using provided
format information for each field they are then decoded and translated into a
standard libpcap file retaining packet order.</p>
<p>Note that each named capturing subgroup has to match <span class="emphasis"><em>exactly</em></span> once a packet,
but they may be present multiple times in the regex.</p>
<p>For example the following dump:</p>
<pre class="screen">&gt; 0:00:00.265620 a130368b000000080060
&gt; 0:00:00.280836 a1216c8b00000000000089086b0b82020407
&lt; 0:00:00.295459 a2010800000000000000000800000000
&gt; 0:00:00.296982 a1303c8b00000008007088286b0bc1ffcbf0f9ff
&gt; 0:00:00.305644 a121718b0000000000008ba86a0b8008
&lt; 0:00:00.319061 a2010900000000000000001000600000
&gt; 0:00:00.330937 a130428b00000008007589186b0bb9ffd9f0fdfa3eb4295e99f3aaffd2f005
&gt; 0:00:00.356037 a121788b0000000000008a18</pre>
<p>could be imported using these settings:</p>
<pre class="screen">regex: ^(?&lt;dir&gt;[&lt;&gt;])\s(?&lt;time&gt;\d+:\d\d:\d\d.\d+)\s(?&lt;data&gt;[0-9a-fA-F]+)$
timestamp: %H:%M:%S.%f
dir: in: &lt;   out: &gt;
encoding: HEX</pre>
<p>Caution has to be applied when discarding the anchors <code class="literal">^</code> and <code class="literal">$</code>, as the input
is searched, not parsed, meaning even most incorrect regexes will produce valid
looking results when not anchored (however anchors are not guaranteed to prevent
this). It is generally recommended to sanity check any files created using
this conversion.</p>
<p>Supported fields:</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
<p class="simpara">data: Actual captured frame data</p>
<p class="simpara">The only mandatory field. This should match the encoded binary data captured and
is used as the actual frame data to import.</p>
</li><li class="listitem">
<p class="simpara">time: timestamp for the packet</p>
<p class="simpara">The captured field will be parsed according to the given timestamp format into a
timestamp.</p>
<p class="simpara">If no timestamp is present an arbitrary counter will count up seconds and
nanoseconds by one each packet.</p>
</li><li class="listitem">
<p class="simpara">dir: the direction the packet was sent over the wire</p>
<p class="simpara">The captured field is expected to be one character in length, any remaining
characters are ignored (e.g. given "Input" only the 'I' is looked at). This
character is compared to lists of characters corresponding to inbound and
outbound and the packet is assigned the corresponding direction.
If neither list yields a match, the direction is set to unknown.</p>
<p class="simpara">If this field is not specified the entire file has no directional information.</p>
</li><li class="listitem">
<p class="simpara">seqno: an ID for this packet</p>
<p class="simpara">Each packet can be assigned a arbitrary ID that can used as field by Wireshark.
This field is assumed to be a positive integer base 10. This field can e.g.
be used to reorder out of order captures after the import.</p>
<p class="simpara">If this field is not given, no IDs will be present in the resulting file.</p>
</li></ul></div>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_the_import_from_hex_dump_dialog_box"></a>5.5.3. The “Import From Hex Dump” Dialog Box</h3></div></div></div>

<p>This dialog box lets you select a text file, containing a hex dump of packet
data, to be imported and set import parameters.</p>
<div class="figure"><a name="ChIOFileImportDialog"></a><p class="title"><b>Figure 5.7. The “Import from Hex Dump” dialog in Hex Dump mode</b></p><div class="figure-contents">

<div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" style="cellpadding: 0; cellspacing: 0;" width="60%"><tr><td><img src="wsug_graphics/ws-file-import.png" width="100%" alt="ws file import"></td></tr></table></div>
</div></div><br class="figure-break">
<p>Specific controls of this import dialog are split in three sections:</p>
<div class="variablelist"><dl class="variablelist"><dt><span class="term">File Source</span></dt><dd>
Determine which input file has to be imported
</dd><dt><span class="term">Input Format</span></dt><dd>
Determine how the input file has to be interpreted.
</dd><dt><span class="term">Encapsulation</span></dt><dd>
Determine how the data is to be encapsulated.
</dd></dl></div>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_file_source"></a>5.5.4. File source</h3></div></div></div>

<div class="variablelist"><dl class="variablelist"><dt><span class="term">Filename / Browse</span></dt><dd>
Enter the name of the text file to import. You can use <span class="emphasis"><em>Browse</em></span> to browse for a
file.
</dd></dl></div>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_input_format"></a>5.5.5. Input Format</h3></div></div></div>

<p>This section is split in the two alternatives for input conversion, accessible in
the two Tabs "Hex Dump" and "Regular Expression"</p>
<p>In addition to the conversion mode specific inputs, there are also common
parameters, currently only the timestamp format.</p>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_the_hex_dump_tab"></a>5.5.5.1. The Hex Dump tab</h4></div></div></div>

<div class="variablelist"><dl class="variablelist"><dt><span class="term">Offsets</span></dt><dd>
Select the radix of the offsets given in the text file to import. This is
usually hexadecimal, but decimal and octal are also supported. Select <span class="emphasis"><em>None</em></span>
when only the bytes are present. These will be imported as a single packet.
</dd><dt><span class="term">Direction indication</span></dt><dd>
Tick this box if the text file to import has direction indicators before each
frame. These are on a separate line before each frame and start with either
<span class="emphasis"><em>I</em></span> or <span class="emphasis"><em>i</em></span> for input and <span class="emphasis"><em>O</em></span> or <span class="emphasis"><em>o</em></span> for output.
</dd></dl></div>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_the_regular_expression_tab"></a>5.5.5.2. The Regular Expression tab</h4></div></div></div>

<div class="figure"><a name="idm1585150384"></a><p class="title"><b>Figure 5.8. The "Regular Expression" tab inside the "Import from Hex Dump” dialog.</b></p><div class="figure-contents">

<div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" style="cellpadding: 0; cellspacing: 0;" width="60%"><tr><td><img src="wsug_graphics/ws-file-import-regex.png" width="100%" alt="ws file import regex"></td></tr></table></div>
</div></div><br class="figure-break">
<div class="variablelist"><dl class="variablelist"><dt><span class="term">Packet format regular expression</span></dt><dd>
This is the regex used for searching packets and metadata inside the input file.
Named capturing subgroups are used to find the individual fields. Anchors <code class="literal">^</code> and
<code class="literal">$</code> are set to match directly before and after newlines <code class="literal">\n</code> or <code class="literal">\r\n</code>. See
<a class="ulink" href="https://developer.gnome.org/glib/stable/glib-regex-syntax.html" target="_top">GRegex</a> for a full
documentation.
</dd><dt><span class="term">Data encoding</span></dt><dd>
<p class="simpara">The Encoding used for the binary data. Supported encodings are plain-hexadecimal,
-octal, -binary and base64. Plain here means no additional
characters are present in the data field beyond whitespaces, which are ignored.
Any unexpected characters abort the import process.</p>
<p class="simpara">Ignored whitespaces are <code class="literal">\r</code>, <code class="literal">\n</code>, <code class="literal">\t</code>, <code class="literal">\v</code>, ` ` and only for hex <code class="literal">:</code>, only
for base64 <code class="literal">=</code>.</p>
<p class="simpara">Any incomplete bytes at the field’s end are assumed to be padding to fill the
last complete byte. These bits should be zero, however this is not checked.</p>
</dd><dt><span class="term">Direction indication</span></dt><dd>
The lists of characters indicating incoming vs. outgoing packets. Tese fields
are only available when the regex contains a <code class="literal">(?&lt;dir&gt;…​)</code> group.
</dd></dl></div>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_common_items"></a>5.5.5.3. Common items</h4></div></div></div>

<div class="variablelist"><dl class="variablelist"><dt><span class="term">Timestamp Format</span></dt><dd>
<p class="simpara">This is the format specifier used to parse the timestamps in the text file to
import. It uses the same format as <code class="literal">strptime(3)</code> with the addition of <code class="literal">%f</code> for
zero padded fractions of seconds. The precision of <code class="literal">%f</code> is determined from it’s
length. The most common fields are <code class="literal">%H</code>, <code class="literal">%M</code> and <code class="literal">%S</code> for hours, minutes and
seconds. The straightforward HH:MM:SS format is covered by %T. For a full
definition of the syntax look for <code class="literal">strptime(3)</code>,</p>
<p class="simpara">In Regex mode this field is only available when a <code class="literal">(?&lt;time&gt;…​)</code> group is present.</p>
<p class="simpara">In Hex Dump mode if there are no timestamps in the text file to import, leave this
field empty and timestamps will be generated based on the time of import.</p>
</dd></dl></div>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_encapsulation"></a>5.5.6. Encapsulation</h3></div></div></div>

<div class="variablelist"><dl class="variablelist"><dt><span class="term">Encapsulation type</span></dt><dd>
Here you can select which type of frames you are importing. This all depends on
from what type of medium the dump to import was taken. It lists all types that
Wireshark understands, so as to pass the capture file contents to the right
dissector.
</dd><dt><span class="term">Dummy header</span></dt><dd>
When Ethernet encapsulation is selected you have to option to prepend dummy
headers to the frames to import. These headers can provide artificial Ethernet,
IP, UDP, TCP or SCTP headers or SCTP data chunks. When selecting a type of
dummy header the applicable entries are enabled, others are grayed out and
default values are used.
When the <span class="emphasis"><em>Wireshark Upper PDU export</em></span> encapsulation is selected the option
<span class="emphasis"><em>ExportPDU</em></span> becomes available. This allows you to select the name of the
dissector these frames are to be directed to.
</dd><dt><span class="term">Maximum frame length</span></dt><dd>
You may not be interested in the full frames from the text file, just the first
part. Here you can define how much data from the start of the frame you want to
import. If you leave this open the maximum is set to 256kiB.
</dd></dl></div>
<p>Once all input and import parameters are setup click <span class="guibutton">Import</span> to start the
import. If your current data wasn’t saved before you will be asked to save it
first.</p>
<p>If the import button doesn’t unlock, make sure all encapsulation parameters are
in the expected range and all unlocked fields are populated when using regex mode
(the placeholder text is not used as default).</p>
<p>When completed there will be a new capture file loaded with the frames imported
from the text file.</p>
</div>
</div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ChIOMergeSection.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="ChapterIO.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="ChIOFileSetSection.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">5.4. Merging Capture Files </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> 5.6. File Sets</td></tr></table></div></body></html>
